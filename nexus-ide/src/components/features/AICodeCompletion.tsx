/**
 * AI Code Completion Component
 * 
 * Advanced AI-powered code completion system that provides intelligent suggestions
 * based on project context, user patterns, and multi-model AI analysis.
 * 
 * Features:
 * * Multi-Model AI Integration (GPT-4, Claude, Llama)
 * * Context-Aware Suggestions
 * * Natural Language Programming
 * * Predictive Typing
 * * Learning from User Patterns
 * * Real-time Code Analysis
 * * Smart Import Suggestions
 * * Code Generation from Comments
 */

import React, { useEffect, useRef, useState, useCallback } from 'react';
import * as monaco from 'monaco-editor';
import { toast } from 'sonner';
import { 
  Brain, 
  Zap, 
  Lightbulb, 
  Code2, 
  Sparkles, 
  MessageSquare,
  Wand2,
  Target
} from 'lucide-react';

export interface AIModel {
  id: string;
  name: string;
  provider: 'openai' | 'anthropic' | 'meta' | 'google';
  model: string;
  enabled: boolean;
  priority: number;
}

export interface CodeContext {
  projectType: string;
  language: string;
  framework?: string;
  dependencies: string[];
  recentFiles: string[];
  currentFile: string;
  cursorPosition: monaco.Position;
  selectedText?: string;
  surroundingCode: string;
}

export interface AISuggestion {
  id: string;
  text: string;
  type: 'completion' | 'snippet' | 'function' | 'import' | 'refactor';
  confidence: number;
  model: string;
  reasoning?: string;
  insertText: string;
  range: monaco.IRange;
  command?: monaco.languages.Command;
}

export interface AICodeCompletionProps {
  editor: monaco.editor.IStandaloneCodeEditor;
  context: CodeContext;
  models: AIModel[];
  onSuggestionAccepted?: (suggestion: AISuggestion) => void;
  onModelToggle?: (modelId: string, enabled: boolean) => void;
  className?: string;
}

const defaultModels: AIModel[] = [
  {
    id: 'gpt-4-turbo',
    name: 'GPT-4 Turbo',
    provider: 'openai',
    model: 'gpt-4-turbo-preview',
    enabled: true,
    priority: 1
  },
  {
    id: 'claude-3-opus',
    name: 'Claude 3 Opus',
    provider: 'anthropic',
    model: 'claude-3-opus-20240229',
    enabled: true,
    priority: 2
  },
  {
    id: 'llama-3-70b',
    name: 'Llama 3 70B',
    provider: 'meta',
    model: 'llama-3-70b-instruct',
    enabled: false,
    priority: 3
  },
  {
    id: 'gemini-pro',
    name: 'Gemini Pro',
    provider: 'google',
    model: 'gemini-pro',
    enabled: false,
    priority: 4
  }
];

export const AICodeCompletion: React.FC<AICodeCompletionProps> = ({
  editor,
  context,
  models = defaultModels,
  onSuggestionAccepted,
  onModelToggle,
  className
}) => {
  const [suggestions, setSuggestions] = useState<AISuggestion[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [showPanel, setShowPanel] = useState(false);
  const [naturalLanguageMode, setNaturalLanguageMode] = useState(false);
  const [userInput, setUserInput] = useState('');
  const [learningData, setLearningData] = useState<any[]>([]);
  const suggestionWidgetRef = useRef<HTMLDivElement>(null);
  const debounceRef = useRef<NodeJS.Timeout>();

  // AI Code Completion Provider
  const createAICompletionProvider = useCallback(() => {
    return {
      provideCompletionItems: async (
        model: monaco.editor.ITextModel,
        position: monaco.Position,
        context: monaco.languages.CompletionContext,
        token: monaco.CancellationToken
      ): Promise<monaco.languages.CompletionList> => {
        if (token.isCancellationRequested) {
          return { suggestions: [] };
        }

        setIsLoading(true);
        
        try {
          const aiSuggestions = await generateAISuggestions({
            model,
            position,
            context: {
              ...context,
              projectType: context.projectType,
              language: model.getLanguageId(),
              currentFile: model.uri.path,
              cursorPosition: position,
              surroundingCode: getSurroundingCode(model, position)
            }
          });

          const monacoSuggestions: monaco.languages.CompletionItem[] = aiSuggestions.map(suggestion => ({
            label: {
              label: suggestion.text,
              description: `AI (${suggestion.model})`,
              detail: suggestion.reasoning
            },
            kind: getCompletionKind(suggestion.type),
            insertText: suggestion.insertText,
            insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
            range: suggestion.range,
            command: suggestion.command,
            sortText: `0${suggestion.confidence.toString().padStart(3, '0')}`,
            filterText: suggestion.text,
            documentation: {
              value: `**AI Suggestion** (Confidence: ${Math.round(suggestion.confidence * 100)}%)\n\n${suggestion.reasoning || 'Generated by AI based on context analysis'}`,
              isTrusted: true
            },
            tags: [monaco.languages.CompletionItemTag.Deprecated] // Custom styling
          }));

          return {
            suggestions: monacoSuggestions,
            incomplete: false
          };
        } catch (error) {
          console.error('AI completion error:', error);
          return { suggestions: [] };
        } finally {
          setIsLoading(false);
        }
      },

      resolveCompletionItem: async (
        item: monaco.languages.CompletionItem,
        token: monaco.CancellationToken
      ): Promise<monaco.languages.CompletionItem> => {
        // Add additional details or documentation
        return item;
      }
    };
  }, [context, models]);

  // Generate AI Suggestions
  const generateAISuggestions = async (params: any): Promise<AISuggestion[]> => {
    const enabledModels = models.filter(m => m.enabled).sort((a, b) => a.priority - b.priority);
    const suggestions: AISuggestion[] = [];

    for (const model of enabledModels) {
      try {
        const modelSuggestions = await callAIModel(model, params);
        suggestions.push(...modelSuggestions);
      } catch (error) {
        console.warn(`AI model ${model.name} failed:`, error);
      }
    }

    // Rank and deduplicate suggestions
    return rankSuggestions(suggestions);
  };

  // Call AI Model
  const callAIModel = async (model: AIModel, params: any): Promise<AISuggestion[]> => {
    // This would integrate with actual AI APIs
    // For now, return mock suggestions
    return [
      {
        id: `${model.id}-1`,
        text: 'async function fetchData()',
        type: 'function',
        confidence: 0.95,
        model: model.name,
        reasoning: 'Based on the context, you likely need an async function to fetch data',
        insertText: 'async function fetchData(${1:url}: string): Promise<${2:any}> {\n\t${3:// Implementation}\n}',
        range: {
          startLineNumber: params.position.lineNumber,
          startColumn: params.position.column,
          endLineNumber: params.position.lineNumber,
          endColumn: params.position.column
        }
      }
    ];
  };

  // Get surrounding code for context
  const getSurroundingCode = (model: monaco.editor.ITextModel, position: monaco.Position): string => {
    const startLine = Math.max(1, position.lineNumber - 10);
    const endLine = Math.min(model.getLineCount(), position.lineNumber + 10);
    
    return model.getValueInRange({
      startLineNumber: startLine,
      startColumn: 1,
      endLineNumber: endLine,
      endColumn: model.getLineMaxColumn(endLine)
    });
  };

  // Get completion kind based on suggestion type
  const getCompletionKind = (type: AISuggestion['type']): monaco.languages.CompletionItemKind => {
    switch (type) {
      case 'function': return monaco.languages.CompletionItemKind.Function;
      case 'snippet': return monaco.languages.CompletionItemKind.Snippet;
      case 'import': return monaco.languages.CompletionItemKind.Module;
      case 'refactor': return monaco.languages.CompletionItemKind.Reference;
      default: return monaco.languages.CompletionItemKind.Text;
    }
  };

  // Rank suggestions by confidence and relevance
  const rankSuggestions = (suggestions: AISuggestion[]): AISuggestion[] => {
    return suggestions
      .sort((a, b) => b.confidence - a.confidence)
      .slice(0, 10); // Limit to top 10 suggestions
  };

  // Natural Language Programming
  const processNaturalLanguage = async (input: string): Promise<void> => {
    if (!input.trim()) return;

    setIsLoading(true);
    try {
      // Convert natural language to code
      const code = await convertNaturalLanguageToCode(input, context);
      
      if (code) {
        const position = editor.getPosition();
        if (position) {
          editor.executeEdits('ai-natural-language', [{
            range: {
              startLineNumber: position.lineNumber,
              startColumn: position.column,
              endLineNumber: position.lineNumber,
              endColumn: position.column
            },
            text: code
          }]);
          
          toast.success('Code generated from natural language!');
        }
      }
    } catch (error) {
      toast.error('Failed to generate code from natural language');
    } finally {
      setIsLoading(false);
      setUserInput('');
    }
  };

  // Convert natural language to code
  const convertNaturalLanguageToCode = async (input: string, context: CodeContext): Promise<string> => {
    // This would call AI APIs to convert natural language to code
    // Mock implementation
    if (input.toLowerCase().includes('create a function')) {
      return `function ${input.split(' ').pop()}() {\n\t// TODO: Implement\n}`;
    }
    return '';
  };

  // Register completion provider
  useEffect(() => {
    if (!editor) return;

    const disposable = monaco.languages.registerCompletionItemProvider(
      context.language,
      createAICompletionProvider()
    );

    return () => disposable.dispose();
  }, [editor, context, models, createAICompletionProvider]);

  // Handle editor changes for learning
  useEffect(() => {
    if (!editor) return;

    const disposable = editor.onDidChangeModelContent((e) => {
      // Debounce to avoid too many calls
      clearTimeout(debounceRef.current);
      debounceRef.current = setTimeout(() => {
        // Learn from user's coding patterns
        learnFromUserInput(e);
      }, 1000);
    });

    return () => {
      disposable.dispose();
      clearTimeout(debounceRef.current);
    };
  }, [editor]);

  // Learn from user input
  const learnFromUserInput = (event: monaco.editor.IModelContentChangedEvent) => {
    // Analyze user's coding patterns and preferences
    const changes = event.changes;
    changes.forEach(change => {
      if (change.text.length > 5) {
        setLearningData(prev => [...prev, {
          timestamp: Date.now(),
          text: change.text,
          context: context.language,
          position: change.range
        }]);
      }
    });
  };

  return (
    <div className={className}>
      {/* AI Panel Toggle */}
      <button
        onClick={() => setShowPanel(!showPanel)}
        className="fixed bottom-4 right-4 p-3 bg-primary text-primary-foreground rounded-full shadow-lg hover:bg-primary/90 transition-colors z-50"
        title="AI Assistant"
      >
        <Brain className="w-5 h-5" />
      </button>

      {/* AI Assistant Panel */}
      {showPanel && (
        <div className="fixed bottom-16 right-4 w-96 bg-background border border-border rounded-lg shadow-xl p-4 z-50">
          <div className="flex items-center justify-between mb-4">
            <h3 className="font-semibold flex items-center gap-2">
              <Sparkles className="w-4 h-4" />
              AI Code Assistant
            </h3>
            <button
              onClick={() => setShowPanel(false)}
              className="text-muted-foreground hover:text-foreground"
            >
              X
            </button>
          </div>

          {/* Natural Language Input */}
          <div className="mb-4">
            <div className="flex items-center gap-2 mb-2">
              <MessageSquare className="w-4 h-4" />
              <span className="text-sm font-medium">Natural Language Programming</span>
            </div>
            <div className="flex gap-2">
              <input
                type="text"
                value={userInput}
                onChange={(e) => setUserInput(e.target.value)}
                placeholder="Describe what you want to code..."
                className="flex-1 px-3 py-2 bg-background border border-border rounded text-sm"
                onKeyPress={(e) => e.key === 'Enter' && processNaturalLanguage(userInput)}
              />
              <button
                onClick={() => processNaturalLanguage(userInput)}
                disabled={isLoading || !userInput.trim()}
                className="px-3 py-2 bg-primary text-primary-foreground rounded text-sm hover:bg-primary/90 disabled:opacity-50"
              >
                <Wand2 className="w-4 h-4" />
              </button>
            </div>
          </div>

          {/* AI Models */}
          <div className="mb-4">
            <div className="flex items-center gap-2 mb-2">
              <Target className="w-4 h-4" />
              <span className="text-sm font-medium">AI Models</span>
            </div>
            <div className="space-y-2">
              {models.map(model => (
                <div key={model.id} className="flex items-center justify-between">
                  <span className="text-sm">{model.name}</span>
                  <input
                    type="checkbox"
                    checked={model.enabled}
                    onChange={(e) => onModelToggle?.(model.id, e.target.checked)}
                    className="rounded"
                  />
                </div>
              ))}
            </div>
          </div>

          {/* Status */}
          {isLoading && (
            <div className="flex items-center gap-2 text-sm text-muted-foreground">
              <div className="animate-spin w-4 h-4 border-2 border-primary border-t-transparent rounded-full" />
              Generating AI suggestions...
            </div>
          )}
        </div>
      )}
    </div>
  );
};

export default AICodeCompletion;