#!/usr/bin/env node

/**
 * Git Memory Sharing Service
 * ‡∏£‡∏∞‡∏ö‡∏ö‡πÅ‡∏ä‡∏£‡πå‡πÑ‡∏ü‡∏•‡πå‡πÅ‡∏•‡∏∞‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏ô git-memory system
 * ‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡πÅ‡∏ä‡∏£‡πå‡πÅ‡∏ö‡∏ö real-time ‡πÅ‡∏•‡∏∞ collaborative
 */

const fs = require('fs').promises;
const path = require('path');
const crypto = require('crypto');
const EventEmitter = require('events');

class GitMemorySharing extends EventEmitter {
    constructor(options = {}) {
        super();
        this.gitMemoryPath = options.gitMemoryPath || path.join(process.cwd(), 'git-memory');
        this.memoryPath = options.memoryPath || path.join(process.cwd(), 'memory');
        this.dataPath = options.dataPath || path.join(process.cwd(), 'data');
        this.sharesPath = path.join(this.dataPath, 'shares');
        
        // ‡∏£‡∏∞‡∏ö‡∏ö‡πÅ‡∏ä‡∏£‡πå
        this.activeShares = new Map();
        this.shareSubscribers = new Map();
        this.sharePermissions = new Map();
        
        // ‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤
        this.config = {
            maxShareSize: 50 * 1024 * 1024, // 50MB
            maxShareDuration: 7 * 24 * 60 * 60 * 1000, // 7 days
            allowedFileTypes: ['.js', '.ts', '.json', '.md', '.txt', '.yml', '.yaml', '.xml'],
            compressionEnabled: true,
            encryptionEnabled: true
        };
        
        this.init();
    }
    
    async init() {
        try {
            // ‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå‡∏ó‡∏µ‡πà‡∏à‡∏≥‡πÄ‡∏õ‡πá‡∏ô
            await this.ensureDirectories();
            
            // ‡πÇ‡∏´‡∏•‡∏î‡∏Å‡∏≤‡∏£‡πÅ‡∏ä‡∏£‡πå‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà
            await this.loadExistingShares();
            
            // ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏£‡∏∞‡∏ö‡∏ö monitoring
            this.startMonitoring();
            
            console.log('ü§ù Git Memory Sharing Service initialized');
            console.log(`üìÅ Shares Path: ${this.sharesPath}`);
            console.log(`üîß Active Shares: ${this.activeShares.size}`);
            
        } catch (error) {
            console.error('‚ùå Failed to initialize Git Memory Sharing:', error.message);
            throw error;
        }
    }
    
    async ensureDirectories() {
        const dirs = [this.gitMemoryPath, this.memoryPath, this.dataPath, this.sharesPath];
        
        for (const dir of dirs) {
            try {
                await fs.access(dir);
            } catch {
                await fs.mkdir(dir, { recursive: true });
                console.log(`üìÅ Created directory: ${dir}`);
            }
        }
    }
    
    // === ‡∏Å‡∏≤‡∏£‡πÅ‡∏ä‡∏£‡πå‡πÑ‡∏ü‡∏•‡πå ===
    
    async shareFile(filePath, recipients, options = {}) {
        try {
            const shareId = this.generateShareId();
            const absolutePath = path.resolve(filePath);
            
            // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÑ‡∏ü‡∏•‡πå
            const fileStats = await fs.stat(absolutePath);
            if (fileStats.size > this.config.maxShareSize) {
                throw new Error(`File too large: ${fileStats.size} bytes`);
            }
            
            // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡πÑ‡∏ü‡∏•‡πå
            const fileExt = path.extname(absolutePath).toLowerCase();
            if (!Array.isArray(this.config.allowedFileTypes) || !this.config.allowedFileTypes.includes(fileExt)) {
                throw new Error(`File type not allowed: ${fileExt}`);
            }
            
            // ‡∏≠‡πà‡∏≤‡∏ô‡πÑ‡∏ü‡∏•‡πå
            const fileContent = await fs.readFile(absolutePath, 'utf8');
            
            // ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡∏≤‡∏£‡πÅ‡∏ä‡∏£‡πå
            const shareData = {
                id: shareId,
                type: 'file',
                originalPath: absolutePath,
                fileName: path.basename(absolutePath),
                fileSize: fileStats.size,
                content: fileContent,
                recipients: Array.isArray(recipients) ? recipients : [recipients],
                permissions: {
                    read: options.read !== false,
                    write: options.write === true,
                    download: options.download !== false,
                    share: options.share === true
                },
                metadata: {
                    createdAt: new Date().toISOString(),
                    createdBy: options.createdBy || 'system',
                    expiresAt: options.expiresAt || new Date(Date.now() + this.config.maxShareDuration).toISOString(),
                    description: options.description || '',
                    tags: options.tags || []
                },
                stats: {
                    views: 0,
                    downloads: 0,
                    lastAccessed: null
                }
            };
            
            // ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Å‡∏≤‡∏£‡πÅ‡∏ä‡∏£‡πå
            await this.saveShare(shareData);
            
            // ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÉ‡∏ô active shares
            this.activeShares.set(shareId, shareData);
            
            // ‡∏™‡πà‡∏á‡∏Å‡∏≤‡∏£‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô
            this.emit('fileShared', {
                shareId,
                fileName: shareData.fileName,
                recipients: shareData.recipients,
                createdBy: shareData.metadata.createdBy
            });
            
            console.log(`üì§ File shared: ${shareData.fileName} (${shareId})`);
            return shareId;
            
        } catch (error) {
            console.error('‚ùå Failed to share file:', error.message);
            throw error;
        }
    }
    
    async shareDirectory(dirPath, recipients, options = {}) {
        try {
            const shareId = this.generateShareId();
            const absolutePath = path.resolve(dirPath);
            
            // ‡∏≠‡πà‡∏≤‡∏ô‡πÑ‡∏ü‡∏•‡πå‡πÉ‡∏ô‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå
            const files = await this.readDirectoryRecursive(absolutePath);
            
            // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ç‡∏ô‡∏≤‡∏î‡∏£‡∏ß‡∏°
            const totalSize = files.reduce((sum, file) => sum + file.size, 0);
            if (totalSize > this.config.maxShareSize) {
                throw new Error(`Directory too large: ${totalSize} bytes`);
            }
            
            // ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡∏≤‡∏£‡πÅ‡∏ä‡∏£‡πå
            const shareData = {
                id: shareId,
                type: 'directory',
                originalPath: absolutePath,
                directoryName: path.basename(absolutePath),
                files: files,
                totalSize: totalSize,
                recipients: Array.isArray(recipients) ? recipients : [recipients],
                permissions: {
                    read: options.read !== false,
                    write: options.write === true,
                    download: options.download !== false,
                    share: options.share === true
                },
                metadata: {
                    createdAt: new Date().toISOString(),
                    createdBy: options.createdBy || 'system',
                    expiresAt: options.expiresAt || new Date(Date.now() + this.config.maxShareDuration).toISOString(),
                    description: options.description || '',
                    tags: options.tags || []
                },
                stats: {
                    views: 0,
                    downloads: 0,
                    lastAccessed: null
                }
            };
            
            // ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Å‡∏≤‡∏£‡πÅ‡∏ä‡∏£‡πå
            await this.saveShare(shareData);
            
            // ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÉ‡∏ô active shares
            this.activeShares.set(shareId, shareData);
            
            // ‡∏™‡πà‡∏á‡∏Å‡∏≤‡∏£‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô
            this.emit('directoryShared', {
                shareId,
                directoryName: shareData.directoryName,
                fileCount: files.length,
                recipients: shareData.recipients,
                createdBy: shareData.metadata.createdBy
            });
            
            console.log(`üìÅ Directory shared: ${shareData.directoryName} (${files.length} files, ${shareId})`);
            return shareId;
            
        } catch (error) {
            console.error('‚ùå Failed to share directory:', error.message);
            throw error;
        }
    }
    
    // === ‡∏Å‡∏≤‡∏£‡πÄ‡∏Ç‡πâ‡∏≤‡∏ñ‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡πÅ‡∏ä‡∏£‡πå ===
    
    async getSharedContent(shareId, userId, options = {}) {
        try {
            const shareData = this.activeShares.get(shareId);
            if (!shareData) {
                throw new Error(`Share not found: ${shareId}`);
            }
            
            // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡πå
            if (!this.checkPermission(shareData, userId, 'read')) {
                throw new Error(`Access denied for user: ${userId}`);
            }
            
            // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡∏´‡∏°‡∏î‡∏≠‡∏≤‡∏¢‡∏∏
            if (new Date() > new Date(shareData.metadata.expiresAt)) {
                throw new Error(`Share expired: ${shareId}`);
            }
            
            // ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏™‡∏ñ‡∏¥‡∏ï‡∏¥
            shareData.stats.views++;
            shareData.stats.lastAccessed = new Date().toISOString();
            await this.updateShare(shareData);
            
            // ‡∏™‡πà‡∏á‡∏Å‡∏≤‡∏£‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô
            this.emit('shareAccessed', {
                shareId,
                userId,
                type: shareData.type,
                fileName: shareData.fileName || shareData.directoryName
            });
            
            // ‡∏™‡πà‡∏á‡∏Ñ‡∏∑‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•
            const result = {
                id: shareData.id,
                type: shareData.type,
                metadata: shareData.metadata,
                permissions: shareData.permissions
            };
            
            if (shareData.type === 'file') {
                result.fileName = shareData.fileName;
                result.content = shareData.content;
                result.fileSize = shareData.fileSize;
            } else if (shareData.type === 'directory') {
                result.directoryName = shareData.directoryName;
                result.files = shareData.files;
                result.totalSize = shareData.totalSize;
            }
            
            return result;
            
        } catch (error) {
            console.error('‚ùå Failed to get shared content:', error.message);
            throw error;
        }
    }
    
    async downloadSharedContent(shareId, userId, downloadPath) {
        try {
            const shareData = this.activeShares.get(shareId);
            if (!shareData) {
                throw new Error(`Share not found: ${shareId}`);
            }
            
            // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡πå
            if (!this.checkPermission(shareData, userId, 'download')) {
                throw new Error(`Download not allowed for user: ${userId}`);
            }
            
            // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡∏´‡∏°‡∏î‡∏≠‡∏≤‡∏¢‡∏∏
            if (new Date() > new Date(shareData.metadata.expiresAt)) {
                throw new Error(`Share expired: ${shareId}`);
            }
            
            // ‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå downloads ‡∏´‡∏≤‡∏Å‡πÑ‡∏°‡πà‡∏°‡∏µ
            await fs.mkdir(downloadPath, { recursive: true });
            
            let downloadedPath;
            
            if (shareData.type === 'file') {
                // ‡∏î‡∏≤‡∏ß‡∏ô‡πå‡πÇ‡∏´‡∏•‡∏î‡πÑ‡∏ü‡∏•‡πå
                downloadedPath = path.join(downloadPath, shareData.fileName);
                await fs.writeFile(downloadedPath, shareData.content, 'utf8');
                
            } else if (shareData.type === 'directory') {
                // ‡∏î‡∏≤‡∏ß‡∏ô‡πå‡πÇ‡∏´‡∏•‡∏î‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå
                const dirPath = path.join(downloadPath, shareData.directoryName);
                await fs.mkdir(dirPath, { recursive: true });
                
                for (const file of shareData.files) {
                    const filePath = path.join(dirPath, file.relativePath);
                    const fileDir = path.dirname(filePath);
                    await fs.mkdir(fileDir, { recursive: true });
                    await fs.writeFile(filePath, file.content, 'utf8');
                }
                
                downloadedPath = dirPath;
            }
            
            // ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏™‡∏ñ‡∏¥‡∏ï‡∏¥
            shareData.stats.downloads++;
            shareData.stats.lastAccessed = new Date().toISOString();
            await this.updateShare(shareData);
            
            // ‡∏™‡πà‡∏á‡∏Å‡∏≤‡∏£‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô
            this.emit('shareDownloaded', {
                shareId,
                userId,
                downloadPath: downloadedPath,
                type: shareData.type
            });
            
            console.log(`üì• Downloaded: ${shareId} to ${downloadedPath}`);
            return downloadedPath;
            
        } catch (error) {
            console.error('‚ùå Failed to download shared content:', error.message);
            throw error;
        }
    }
    
    // === ‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡πå ===
    
    checkPermission(shareData, userId, action) {
        // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡πÄ‡∏õ‡πá‡∏ô recipient
        if ((!Array.isArray(shareData.recipients) || !shareData.recipients.includes(userId)) && (!Array.isArray(shareData.recipients) || !shareData.recipients.includes('*'))) {
            return false;
        }
        
        // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡πå‡πÄ‡∏â‡∏û‡∏≤‡∏∞
        return shareData.permissions[action] === true;
    }
    
    async updateSharePermissions(shareId, userId, newPermissions) {
        try {
            const shareData = this.activeShares.get(shareId);
            if (!shareData) {
                throw new Error(`Share not found: ${shareId}`);
            }
            
            // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡πå‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç (‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏ú‡∏π‡πâ‡∏™‡∏£‡πâ‡∏≤‡∏á)
            if (shareData.metadata.createdBy !== userId) {
                throw new Error(`Permission denied: Only creator can modify permissions`);
            }
            
            // ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡πå
            shareData.permissions = { ...shareData.permissions, ...newPermissions };
            await this.updateShare(shareData);
            
            console.log(`üîê Updated permissions for share: ${shareId}`);
            return true;
            
        } catch (error) {
            console.error('‚ùå Failed to update share permissions:', error.message);
            throw error;
        }
    }
    
    // === ‡∏£‡∏∞‡∏ö‡∏ö Subscription ===
    
    subscribeToShare(shareId, userId, callback) {
        const key = `${shareId}:${userId}`;
        
        if (!this.shareSubscribers.has(shareId)) {
            this.shareSubscribers.set(shareId, new Map());
        }
        
        this.shareSubscribers.get(shareId).set(userId, callback);
        
        console.log(`üîî User ${userId} subscribed to share: ${shareId}`);
        
        // ‡∏™‡πà‡∏á‡∏Ñ‡∏∑‡∏ô unsubscribe function
        return () => {
            const subscribers = this.shareSubscribers.get(shareId);
            if (subscribers) {
                subscribers.delete(userId);
                if (subscribers.size === 0) {
                    this.shareSubscribers.delete(shareId);
                }
            }
            console.log(`üîï User ${userId} unsubscribed from share: ${shareId}`);
        };
    }
    
    notifySubscribers(shareId, event, data) {
        const subscribers = this.shareSubscribers.get(shareId);
        if (subscribers) {
            subscribers.forEach((callback, userId) => {
                try {
                    callback(event, data);
                } catch (error) {
                    console.error(`‚ùå Failed to notify subscriber ${userId}:`, error.message);
                }
            });
        }
    }
    
    // === Helper Methods ===
    
    generateShareId() {
        return crypto.randomBytes(16).toString('hex');
    }
    
    async readDirectoryRecursive(dirPath) {
        const files = [];
        
        async function readDir(currentPath, relativePath = '') {
            const entries = await fs.readdir(currentPath, { withFileTypes: true });
            
            for (const entry of entries) {
                const fullPath = path.join(currentPath, entry.name);
                const relPath = path.join(relativePath, entry.name);
                
                if (entry.isDirectory()) {
                    await readDir(fullPath, relPath);
                } else if (entry.isFile()) {
                    const stats = await fs.stat(fullPath);
                    const content = await fs.readFile(fullPath, 'utf8');
                    
                    files.push({
                        name: entry.name,
                        relativePath: relPath,
                        size: stats.size,
                        content: content,
                        lastModified: stats.mtime.toISOString()
                    });
                }
            }
        }
        
        await readDir(dirPath);
        return files;
    }
    
    async saveShare(shareData) {
        const filePath = path.join(this.sharesPath, `${shareData.id}.json`);
        await fs.writeFile(filePath, JSON.stringify(shareData, null, 2), 'utf8');
    }
    
    async updateShare(shareData) {
        await this.saveShare(shareData);
        this.activeShares.set(shareData.id, shareData);
    }
    
    async loadExistingShares() {
        try {
            const files = await fs.readdir(this.sharesPath);
            
            for (const file of files) {
                if (file.endsWith('.json')) {
                    const filePath = path.join(this.sharesPath, file);
                    const content = await fs.readFile(filePath, 'utf8');
                    const shareData = JSON.parse(content);
                    
                    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡∏´‡∏°‡∏î‡∏≠‡∏≤‡∏¢‡∏∏
                    if (new Date() > new Date(shareData.metadata.expiresAt)) {
                        await fs.unlink(filePath);
                        console.log(`üóëÔ∏è Removed expired share: ${shareData.id}`);
                        continue;
                    }
                    
                    this.activeShares.set(shareData.id, shareData);
                }
            }
            
            console.log(`üìö Loaded ${this.activeShares.size} existing shares`);
            
        } catch (error) {
            console.error('‚ùå Failed to load existing shares:', error.message);
        }
    }
    
    startMonitoring() {
        // ‡∏ó‡∏≥‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏∞‡∏≠‡∏≤‡∏î‡∏Å‡∏≤‡∏£‡πÅ‡∏ä‡∏£‡πå‡∏ó‡∏µ‡πà‡∏´‡∏°‡∏î‡∏≠‡∏≤‡∏¢‡∏∏‡∏ó‡∏∏‡∏Å 1 ‡∏ä‡∏±‡πà‡∏ß‡πÇ‡∏°‡∏á
        setInterval(async () => {
            await this.cleanupExpiredShares();
        }, 60 * 60 * 1000);
        
        console.log('üîÑ Share monitoring started');
    }
    
    async cleanupExpiredShares() {
        const now = new Date();
        const expiredShares = [];
        
        for (const [shareId, shareData] of this.activeShares) {
            if (now > new Date(shareData.metadata.expiresAt)) {
                expiredShares.push(shareId);
            }
        }
        
        for (const shareId of expiredShares) {
            await this.removeShare(shareId);
        }
        
        if (expiredShares.length > 0) {
            console.log(`üóëÔ∏è Cleaned up ${expiredShares.length} expired shares`);
        }
    }
    
    async removeShare(shareId) {
        try {
            // ‡∏•‡∏ö‡∏à‡∏≤‡∏Å active shares
            this.activeShares.delete(shareId);
            
            // ‡∏•‡∏ö‡πÑ‡∏ü‡∏•‡πå
            const filePath = path.join(this.sharesPath, `${shareId}.json`);
            await fs.unlink(filePath);
            
            // ‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô subscribers
            this.notifySubscribers(shareId, 'shareRemoved', { shareId });
            
            // ‡∏•‡∏ö subscribers
            this.shareSubscribers.delete(shareId);
            
            console.log(`üóëÔ∏è Removed share: ${shareId}`);
            
        } catch (error) {
            console.error(`‚ùå Failed to remove share ${shareId}:`, error.message);
        }
    }
    
    // === API Methods ===
    
    async getSharesList(userId) {
        const shares = [];
        
        for (const [shareId, shareData] of this.activeShares) {
            if ((Array.isArray(shareData.recipients) && shareData.recipients.includes(userId)) || (Array.isArray(shareData.recipients) && shareData.recipients.includes('*')) || shareData.metadata.createdBy === userId) {
                shares.push({
                    id: shareData.id,
                    type: shareData.type,
                    name: shareData.fileName || shareData.directoryName,
                    size: shareData.fileSize || shareData.totalSize,
                    createdAt: shareData.metadata.createdAt,
                    createdBy: shareData.metadata.createdBy,
                    expiresAt: shareData.metadata.expiresAt,
                    stats: shareData.stats,
                    permissions: shareData.permissions
                });
            }
        }
        
        return shares.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));
    }
    
    async getStats() {
        return {
            totalShares: this.activeShares.size,
            totalSubscribers: Array.from(this.shareSubscribers.values()).reduce((sum, subs) => sum + subs.size, 0),
            sharesByType: {
                file: Array.from(this.activeShares.values()).filter(s => s.type === 'file').length,
                directory: Array.from(this.activeShares.values()).filter(s => s.type === 'directory').length
            },
            totalViews: Array.from(this.activeShares.values()).reduce((sum, s) => sum + s.stats.views, 0),
            totalDownloads: Array.from(this.activeShares.values()).reduce((sum, s) => sum + s.stats.downloads, 0),
            timestamp: new Date().toISOString()
        };
    }
}

// === Demo Usage ===

async function demo() {
    try {
        console.log('üöÄ Starting Git Memory Sharing Demo...');
        
        const sharing = new GitMemorySharing();
        
        // ‡∏£‡∏≠‡πÉ‡∏´‡πâ‡∏£‡∏∞‡∏ö‡∏ö‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô
        await new Promise(resolve => setTimeout(resolve, 1000));
        
        // ‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡πÅ‡∏ä‡∏£‡πå‡πÑ‡∏ü‡∏•‡πå
        console.log('\nüì§ Testing file sharing...');
        const shareId1 = await sharing.shareFile('package.json', ['user123', 'admin'], {
            description: 'Project package.json',
            tags: ['config', 'npm'],
            createdBy: 'system'
        });
        
        // ‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡πÄ‡∏Ç‡πâ‡∏≤‡∏ñ‡∏∂‡∏á‡πÑ‡∏ü‡∏•‡πå‡∏ó‡∏µ‡πà‡πÅ‡∏ä‡∏£‡πå
        console.log('\nüì• Testing shared file access...');
        const sharedFile = await sharing.getSharedContent(shareId1, 'user123');
        console.log(`üìÑ Accessed shared file: ${sharedFile.fileName} (${sharedFile.fileSize} bytes)`);
        
        // ‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡πÅ‡∏ä‡∏£‡πå‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå
        console.log('\nüìÅ Testing directory sharing...');
        const shareId2 = await sharing.shareDirectory('src/ai', ['team'], {
            description: 'AI modules directory',
            tags: ['ai', 'modules'],
            createdBy: 'system'
        });
        
        // ‡∏ó‡∏î‡∏™‡∏≠‡∏ö subscription
        console.log('\nüîî Testing subscription...');
        const unsubscribe = sharing.subscribeToShare(shareId1, 'user123', (event, data) => {
            console.log(`üì¢ Notification: ${event}`, data);
        });
        
        // ‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡∏î‡∏≤‡∏ß‡∏ô‡πå‡πÇ‡∏´‡∏•‡∏î
        console.log('\nüì• Testing download...');
        const downloadPath = await sharing.downloadSharedContent(shareId1, 'user123', './downloads');
        console.log(`üì• Downloaded to: ${downloadPath}`);
        
        // ‡πÅ‡∏™‡∏î‡∏á‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏Å‡∏≤‡∏£‡πÅ‡∏ä‡∏£‡πå
        console.log('\nüìã Getting shares list...');
        const sharesList = await sharing.getSharesList('user123');
        console.log(`üìã Found ${sharesList.length} shares for user123`);
        
        // ‡πÅ‡∏™‡∏î‡∏á‡∏™‡∏ñ‡∏¥‡∏ï‡∏¥
        console.log('\nüìä Git Memory Sharing Stats:');
        const stats = await sharing.getStats();
        console.log(JSON.stringify(stats, null, 2));
        
        // ‡∏ó‡∏≥‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏∞‡∏≠‡∏≤‡∏î
        unsubscribe();
        
        console.log('\n‚úÖ Git Memory Sharing demo completed successfully!');
        
    } catch (error) {
        console.error('‚ùå Demo failed:', error.message);
        process.exit(1);
    }
}

// ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô demo ‡∏ñ‡πâ‡∏≤‡πÑ‡∏ü‡∏•‡πå‡∏ô‡∏µ‡πâ‡∏ñ‡∏π‡∏Å‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡πÉ‡∏ä‡πâ‡πÇ‡∏î‡∏¢‡∏ï‡∏£‡∏á
if (require.main === module) {
    demo();
}

module.exports = { GitMemorySharing };