// üöÄ Demo: ‡∏Å‡∏≤‡∏£‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô‡πÇ‡∏Ñ‡πâ‡∏î‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡∏±‡∏ö MCP System
// Code Writing and Data Connection Demo

const http = require('http');
const fs = require('fs');

// üéØ ‡∏Ñ‡∏•‡∏≤‡∏™‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ
class UserManager {
    constructor(mcpConnector) {
        this.mcp = mcpConnector;
        this.users = [];
    }

    // ‚ûï ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡πÉ‡∏´‡∏°‡πà
    async addUser(userData) {
        const user = {
            id: Date.now(),
            name: userData.name,
            email: userData.email,
            role: userData.role || 'user',
            createdAt: new Date().toISOString(),
            isActive: true
        };
        
        // ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏•‡∏á MCP Memory
        await this.mcp.storeMemory(`user_${user.id}`, user);
        
        // ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÉ‡∏ô array ‡∏ó‡πâ‡∏≠‡∏á‡∏ñ‡∏¥‡πà‡∏ô
        this.users.push(user);
        
        console.log(`‚úÖ ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ: ${user.name} (ID: ${user.id})`);
        return user;
    }

    // üìã ‡∏î‡∏π‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
    async getAllUsers() {
        try {
            // ‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡∏à‡∏≤‡∏Å MCP Memory
            const userKeys = await this.mcp.searchMemory('user_');
            const users = [];
            
            for (const key of userKeys) {
                const user = await this.mcp.retrieveMemory(key);
                if (user) users.push(user);
            }
            
            console.log(`üìã ‡∏û‡∏ö‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î: ${users.length} ‡∏Ñ‡∏ô`);
            return users;
        } catch (error) {
            console.error('‚ùå ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏î‡∏∂‡∏á‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ:', error.message);
            return [];
        }
    }

    // üîç ‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ
    async findUser(searchTerm) {
        const users = await this.getAllUsers();
        const found = users.filter(user => 
            user.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
            user.email.toLowerCase().includes(searchTerm.toLowerCase())
        );
        
        console.log(`üîç ‡∏û‡∏ö‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡∏ó‡∏µ‡πà‡∏ï‡∏£‡∏á‡∏Å‡∏±‡∏ö "${searchTerm}": ${found.length} ‡∏Ñ‡∏ô`);
        return found;
    }

    // üìä ‡∏™‡∏ñ‡∏¥‡∏ï‡∏¥‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ
    async getUserStats() {
        const users = await this.getAllUsers();
        const stats = {
            total: users.length,
            active: users.filter(u => u.isActive).length,
            roles: {},
            recentUsers: users.filter(u => {
                const created = new Date(u.createdAt);
                const dayAgo = new Date(Date.now() - 24 * 60 * 60 * 1000);
                return created > dayAgo;
            }).length
        };
        
        // ‡∏ô‡∏±‡∏ö‡∏ï‡∏≤‡∏° role
        users.forEach(user => {
            stats.roles[user.role] = (stats.roles[user.role] || 0) + 1;
        });
        
        return stats;
    }
}

// üõí ‡∏Ñ‡∏•‡∏≤‡∏™‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤
class ProductManager {
    constructor(mcpConnector) {
        this.mcp = mcpConnector;
    }

    // ‚ûï ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤
    async addProduct(productData) {
        const product = {
            id: Date.now(),
            name: productData.name,
            price: productData.price,
            category: productData.category,
            stock: productData.stock || 0,
            description: productData.description || '',
            createdAt: new Date().toISOString(),
            isAvailable: true
        };
        
        await this.mcp.storeMemory(`product_${product.id}`, product);
        console.log(`‚úÖ ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤: ${product.name} (‡∏£‡∏≤‡∏Ñ‡∏≤: ${product.price} ‡∏ö‡∏≤‡∏ó)`);
        return product;
    }

    // üì¶ ‡∏î‡∏π‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
    async getAllProducts() {
        try {
            const productKeys = await this.mcp.searchMemory('product_');
            const products = [];
            
            for (const key of productKeys) {
                const product = await this.mcp.retrieveMemory(key);
                if (product) products.push(product);
            }
            
            console.log(`üì¶ ‡∏û‡∏ö‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î: ${products.length} ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£`);
            return products;
        } catch (error) {
            console.error('‚ùå ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏î‡∏∂‡∏á‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤:', error.message);
            return [];
        }
    }

    // üí∞ ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏°‡∏π‡∏•‡∏Ñ‡πà‡∏≤‡∏™‡∏ï‡πá‡∏≠‡∏Å
    async calculateInventoryValue() {
        const products = await this.getAllProducts();
        const totalValue = products.reduce((sum, product) => {
            return sum + (product.price * product.stock);
        }, 0);
        
        console.log(`üí∞ ‡∏°‡∏π‡∏•‡∏Ñ‡πà‡∏≤‡∏™‡∏ï‡πá‡∏≠‡∏Å‡∏£‡∏ß‡∏°: ${totalValue.toLocaleString()} ‡∏ö‡∏≤‡∏ó`);
        return totalValue;
    }
}

// üåê ‡∏Ñ‡∏•‡∏≤‡∏™‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠ MCP
class MCPConnector {
    constructor(mcpUrl = 'http://localhost:9090') {
        this.mcpUrl = mcpUrl;
        this.isConnected = false;
    }

    // ‚úÖ ‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠
    async connect() {
        try {
            const response = await this.makeRequest('/health');
            if (response.status === 'healthy') {
                this.isConnected = true;
                console.log('‚úÖ ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠ MCP ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à!');
                return true;
            }
        } catch (error) {
            console.error('‚ùå ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠ MCP:', error.message);
            return false;
        }
    }

    // üíæ ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏•‡∏á‡∏´‡∏ô‡πà‡∏ß‡∏¢‡∏Ñ‡∏ß‡∏≤‡∏°‡∏à‡∏≥
    async storeMemory(key, data) {
        try {
            const response = await this.makeRequest('/mcp/memory', {
                method: 'POST',
                data: {
                    method: 'tools/call',
                    params: {
                        name: 'store_memory',
                        arguments: {
                            key: key,
                            value: JSON.stringify(data),
                            metadata: {
                                type: typeof data,
                                timestamp: new Date().toISOString()
                            }
                        }
                    }
                }
            });
            return response;
        } catch (error) {
            console.error(`‚ùå ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å ${key}:`, error.message);
            throw error;
        }
    }

    // üìñ ‡∏≠‡πà‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å‡∏´‡∏ô‡πà‡∏ß‡∏¢‡∏Ñ‡∏ß‡∏≤‡∏°‡∏à‡∏≥
    async retrieveMemory(key) {
        try {
            const response = await this.makeRequest('/mcp/memory', {
                method: 'POST',
                data: {
                    method: 'tools/call',
                    params: {
                        name: 'retrieve_memory',
                        arguments: { key: key }
                    }
                }
            });
            
            if (response.content && response.content[0] && response.content[0].text) {
                return JSON.parse(response.content[0].text);
            }
            return null;
        } catch (error) {
            console.error(`‚ùå ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏≠‡πà‡∏≤‡∏ô ${key}:`, error.message);
            return null;
        }
    }

    // üîç ‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•
    async searchMemory(pattern) {
        try {
            const response = await this.makeRequest('/mcp/memory', {
                method: 'POST',
                data: {
                    method: 'tools/call',
                    params: {
                        name: 'search_memory',
                        arguments: { pattern: pattern }
                    }
                }
            });
            
            if (response.content && response.content[0] && response.content[0].text) {
                return JSON.parse(response.content[0].text);
            }
            return [];
        } catch (error) {
            console.error(`‚ùå ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤ ${pattern}:`, error.message);
            return [];
        }
    }

    // üåê ‡∏™‡πà‡∏á HTTP Request
    async makeRequest(path, options = {}) {
        return new Promise((resolve, reject) => {
            const url = `${this.mcpUrl}${path}`;
            const method = options.method || 'GET';
            const data = options.data ? JSON.stringify(options.data) : null;
            
            const req = http.request(url, {
                method: method,
                headers: {
                    'Content-Type': 'application/json',
                    'Accept': 'application/json',
                    ...(data && { 'Content-Length': Buffer.byteLength(data) })
                }
            }, (res) => {
                let body = '';
                res.on('data', chunk => body += chunk);
                res.on('end', () => {
                    try {
                        const response = JSON.parse(body);
                        resolve(response);
                    } catch (error) {
                        reject(new Error(`Invalid JSON response: ${body}`));
                    }
                });
            });
            
            req.on('error', reject);
            
            if (data) {
                req.write(data);
            }
            
            req.end();
        });
    }
}

// üß™ ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏≤‡∏ò‡∏¥‡∏ï‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô
async function runCodeDemo() {
    console.log('üöÄ ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏™‡∏≤‡∏ò‡∏¥‡∏ï‡∏Å‡∏≤‡∏£‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô‡πÇ‡∏Ñ‡πâ‡∏î‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•\n');
    
    // 1. ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠ MCP
    const mcp = new MCPConnector();
    const connected = await mcp.connect();
    
    if (!connected) {
        console.log('‚ùå ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡πÑ‡∏î‡πâ');
        return;
    }
    
    // 2. ‡∏™‡∏£‡πâ‡∏≤‡∏á Manager classes
    const userManager = new UserManager(mcp);
    const productManager = new ProductManager(mcp);
    
    console.log('\nüë• === ‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ ===');
    
    // 3. ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á
    await userManager.addUser({
        name: '‡∏™‡∏°‡∏ä‡∏≤‡∏¢ ‡πÉ‡∏à‡∏î‡∏µ',
        email: 'somchai@example.com',
        role: 'admin'
    });
    
    await userManager.addUser({
        name: '‡∏™‡∏°‡∏´‡∏ç‡∏¥‡∏á ‡∏£‡∏±‡∏Å‡∏á‡∏≤‡∏ô',
        email: 'somying@example.com',
        role: 'user'
    });
    
    await userManager.addUser({
        name: '‡∏ß‡∏¥‡∏ä‡∏±‡∏¢ ‡πÄ‡∏Å‡πà‡∏á‡∏°‡∏≤‡∏Å',
        email: 'wichai@example.com',
        role: 'manager'
    });
    
    // 4. ‡∏î‡∏π‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ
    const users = await userManager.getAllUsers();
    console.log('\nüìã ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ:');
    users.forEach(user => {
        console.log(`  - ${user.name} (${user.email}) - ${user.role}`);
    });
    
    // 5. ‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ
    const foundUsers = await userManager.findUser('‡∏™‡∏°');
    console.log('\nüîç ‡∏ú‡∏•‡∏Å‡∏≤‡∏£‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤ "‡∏™‡∏°":');
    foundUsers.forEach(user => {
        console.log(`  - ${user.name}`);
    });
    
    // 6. ‡∏™‡∏ñ‡∏¥‡∏ï‡∏¥‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ
    const userStats = await userManager.getUserStats();
    console.log('\nüìä ‡∏™‡∏ñ‡∏¥‡∏ï‡∏¥‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ:');
    console.log(`  - ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î: ${userStats.total} ‡∏Ñ‡∏ô`);
    console.log(`  - ‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏≠‡∏¢‡∏π‡πà: ${userStats.active} ‡∏Ñ‡∏ô`);
    console.log(`  - ‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡πÉ‡∏´‡∏°‡πà‡∏ß‡∏±‡∏ô‡∏ô‡∏µ‡πâ: ${userStats.recentUsers} ‡∏Ñ‡∏ô`);
    console.log('  - ‡∏ï‡∏≤‡∏° Role:');
    Object.entries(userStats.roles).forEach(([role, count]) => {
        console.log(`    * ${role}: ${count} ‡∏Ñ‡∏ô`);
    });
    
    console.log('\nüì¶ === ‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤ ===');
    
    // 7. ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á
    await productManager.addProduct({
        name: '‡πÇ‡∏ô‡πä‡∏ï‡∏ö‡∏∏‡πä‡∏Ñ Dell XPS 13',
        price: 45000,
        category: '‡∏Ñ‡∏≠‡∏°‡∏û‡∏¥‡∏ß‡πÄ‡∏ï‡∏≠‡∏£‡πå',
        stock: 10,
        description: '‡πÇ‡∏ô‡πä‡∏ï‡∏ö‡∏∏‡πä‡∏Ñ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ó‡∏≥‡∏á‡∏≤‡∏ô'
    });
    
    await productManager.addProduct({
        name: '‡πÄ‡∏°‡∏≤‡∏™‡πå‡πÑ‡∏£‡πâ‡∏™‡∏≤‡∏¢ Logitech',
        price: 1200,
        category: '‡∏≠‡∏∏‡∏õ‡∏Å‡∏£‡∏ì‡πå',
        stock: 25,
        description: '‡πÄ‡∏°‡∏≤‡∏™‡πå‡πÑ‡∏£‡πâ‡∏™‡∏≤‡∏¢‡∏Ñ‡∏∏‡∏ì‡∏†‡∏≤‡∏û‡∏™‡∏π‡∏á'
    });
    
    await productManager.addProduct({
        name: '‡∏Ñ‡∏µ‡∏¢‡πå‡∏ö‡∏≠‡∏£‡πå‡∏î‡πÄ‡∏Å‡∏°‡∏°‡∏¥‡πà‡∏á',
        price: 3500,
        category: '‡∏≠‡∏∏‡∏õ‡∏Å‡∏£‡∏ì‡πå',
        stock: 15,
        description: '‡∏Ñ‡∏µ‡∏¢‡πå‡∏ö‡∏≠‡∏£‡πå‡∏î‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÄ‡∏•‡πà‡∏ô‡πÄ‡∏Å‡∏°'
    });
    
    // 8. ‡∏î‡∏π‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤
    const products = await productManager.getAllProducts();
    console.log('\nüì¶ ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤:');
    products.forEach(product => {
        console.log(`  - ${product.name}: ${product.price.toLocaleString()} ‡∏ö‡∏≤‡∏ó (‡∏Ñ‡∏á‡πÄ‡∏´‡∏•‡∏∑‡∏≠: ${product.stock})`);
    });
    
    // 9. ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏°‡∏π‡∏•‡∏Ñ‡πà‡∏≤‡∏™‡∏ï‡πá‡∏≠‡∏Å
    const inventoryValue = await productManager.calculateInventoryValue();
    
    // 10. ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏£‡∏≤‡∏¢‡∏á‡∏≤‡∏ô‡∏™‡∏£‡∏∏‡∏õ
    const report = {
        timestamp: new Date().toISOString(),
        summary: {
            users: userStats,
            products: {
                total: products.length,
                totalValue: inventoryValue,
                categories: [...new Set(products.map(p => p.category))]
            }
        },
        demo: 'completed'
    };
    
    // ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏£‡∏≤‡∏¢‡∏á‡∏≤‡∏ô
    fs.writeFileSync('code-demo-report.json', JSON.stringify(report, null, 2));
    
    console.log('\nüéØ === ‡∏™‡∏£‡∏∏‡∏õ‡∏Å‡∏≤‡∏£‡∏™‡∏≤‡∏ò‡∏¥‡∏ï ===');
    console.log('‚úÖ ‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠ MCP: ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à');
    console.log('‚úÖ ‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ: ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à');
    console.log('‚úÖ ‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤: ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à');
    console.log('‚úÖ ‡∏Å‡∏≤‡∏£‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•: ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à');
    console.log('‚úÖ ‡∏Å‡∏≤‡∏£‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏™‡∏ñ‡∏¥‡∏ï‡∏¥: ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à');
    console.log('üìÑ ‡∏£‡∏≤‡∏¢‡∏á‡∏≤‡∏ô‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÉ‡∏ô: code-demo-report.json');
    
    console.log('\nüí° ‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏ô‡∏µ‡πâ‡πÅ‡∏™‡∏î‡∏á‡πÉ‡∏´‡πâ‡πÄ‡∏´‡πá‡∏ô:');
    console.log('  - ‡∏Å‡∏≤‡∏£‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô‡πÇ‡∏Ñ‡πâ‡∏î Object-Oriented Programming');
    console.log('  - ‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏Å‡∏±‡∏ö MCP Memory System');
    console.log('  - ‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÅ‡∏ö‡∏ö CRUD (Create, Read, Update, Delete)');
    console.log('  - ‡∏Å‡∏≤‡∏£‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡πÅ‡∏•‡∏∞‡∏Å‡∏£‡∏≠‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•');
    console.log('  - ‡∏Å‡∏≤‡∏£‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡πÅ‡∏•‡∏∞‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏£‡∏≤‡∏¢‡∏á‡∏≤‡∏ô');
    console.log('  - ‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ Error ‡πÅ‡∏•‡∏∞ Exception');
}

// üéØ ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏Å‡∏≤‡∏£‡∏™‡∏≤‡∏ò‡∏¥‡∏ï
if (require.main === module) {
    runCodeDemo().catch(error => {
        console.error('‚ùå ‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î:', error.message);
    });
}

// ‡∏™‡πà‡∏á‡∏≠‡∏≠‡∏Å‡∏Ñ‡∏•‡∏≤‡∏™‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô
module.exports = {
    MCPConnector,
    UserManager,
    ProductManager,
    runCodeDemo
};