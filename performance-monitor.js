const os = require('os');
const fs = require('fs');
const path = require('path');

// üé® ‡∏™‡∏µ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö console
const colors = {
  reset: '\x1b[0m',
  bright: '\x1b[1m',
  red: '\x1b[31m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  magenta: '\x1b[35m',
  cyan: '\x1b[36m',
  white: '\x1b[37m'
};

// üìä ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏ñ‡∏¥‡∏ï‡∏¥
let stats = {
  startTime: Date.now(),
  maxMemory: 0,
  avgMemory: 0,
  memoryReadings: [],
  maxCpu: 0,
  avgCpu: 0,
  cpuReadings: [],
  warnings: 0,
  alerts: 0
};

// üéØ ‡πÄ‡∏Å‡∏ì‡∏ë‡πå‡∏Å‡∏≤‡∏£‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô
const thresholds = {
  memory: {
    warning: 1024, // 1GB
    critical: 2048 // 2GB
  },
  cpu: {
    warning: 50, // 50%
    critical: 80 // 80%
  }
};

// üìù ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å log
function writeLog(message, level = 'INFO') {
  const timestamp = new Date().toISOString();
  const logMessage = `[${timestamp}] [${level}] ${message}\n`;
  
  try {
    fs.appendFileSync('performance.log', logMessage);
  } catch (error) {
    console.error('‚ùå Cannot write to log file:', error.message);
  }
}

// üîÑ ‡πÅ‡∏õ‡∏•‡∏á‡πÑ‡∏ö‡∏ï‡πå‡πÄ‡∏õ‡πá‡∏ô MB
function bytesToMB(bytes) {
  return Math.round(bytes / 1024 / 1024);
}

// üìä ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡πÄ‡∏õ‡∏≠‡∏£‡πå‡πÄ‡∏ã‡πá‡∏ô‡∏ï‡πå CPU
function calculateCpuPercent(cpuUsage) {
  const totalTime = cpuUsage.user + cpuUsage.system;
  return Math.round((totalTime / 1000000) * 100); // ‡πÅ‡∏õ‡∏•‡∏á‡∏à‡∏≤‡∏Å microseconds
}

// üé® ‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÅ‡∏ñ‡∏ö‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏•
function createProgressBar(value, max, width = 20) {
  const percentage = Math.min(100, (value / max) * 100);
  const filled = Math.round((percentage / 100) * width);
  const empty = width - filled;
  
  let color = colors.green;
  if (percentage > 80) color = colors.red;
  else if (percentage > 60) color = colors.yellow;
  
  return `${color}${'‚ñà'.repeat(filled)}${'‚ñë'.repeat(empty)}${colors.reset} ${percentage.toFixed(1)}%`;
}

// üìä ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏õ‡∏£‡∏∞‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡∏†‡∏≤‡∏û
function monitorPerformance() {
  const memUsage = process.memoryUsage();
  const cpuUsage = process.cpuUsage();
  const systemMem = os.totalmem();
  const freeMem = os.freemem();
  const usedSystemMem = systemMem - freeMem;
  
  // üíæ ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏´‡∏ô‡πà‡∏ß‡∏¢‡∏Ñ‡∏ß‡∏≤‡∏°‡∏à‡∏≥
  const heapUsedMB = bytesToMB(memUsage.heapUsed);
  const heapTotalMB = bytesToMB(memUsage.heapTotal);
  const rssMB = bytesToMB(memUsage.rss);
  const externalMB = bytesToMB(memUsage.external);
  const systemMemMB = bytesToMB(systemMem);
  const usedSystemMemMB = bytesToMB(usedSystemMem);
  const freeMemMB = bytesToMB(freeMem);
  
  // ‚ö° ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• CPU
  const cpuPercent = calculateCpuPercent(cpuUsage);
  const loadAvg = os.loadavg();
  const cpuCount = os.cpus().length;
  
  // üìà ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏™‡∏ñ‡∏¥‡∏ï‡∏¥
  stats.maxMemory = Math.max(stats.maxMemory, heapUsedMB);
  stats.memoryReadings.push(heapUsedMB);
  if (stats.memoryReadings.length > 60) stats.memoryReadings.shift(); // ‡πÄ‡∏Å‡πá‡∏ö 60 ‡∏Ñ‡πà‡∏≤‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î
  stats.avgMemory = stats.memoryReadings.reduce((a, b) => a + b, 0) / stats.memoryReadings.length;
  
  stats.maxCpu = Math.max(stats.maxCpu, cpuPercent);
  stats.cpuReadings.push(cpuPercent);
  if (stats.cpuReadings.length > 60) stats.cpuReadings.shift();
  stats.avgCpu = stats.cpuReadings.reduce((a, b) => a + b, 0) / stats.cpuReadings.length;
  
  // üö® ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô
  let alertLevel = 'NORMAL';
  let alertColor = colors.green;
  
  if (heapUsedMB > thresholds.memory.critical || cpuPercent > thresholds.cpu.critical) {
    alertLevel = 'CRITICAL';
    alertColor = colors.red;
    stats.alerts++;
    writeLog(`CRITICAL: Memory ${heapUsedMB}MB, CPU ${cpuPercent}%`, 'CRITICAL');
  } else if (heapUsedMB > thresholds.memory.warning || cpuPercent > thresholds.cpu.warning) {
    alertLevel = 'WARNING';
    alertColor = colors.yellow;
    stats.warnings++;
    writeLog(`WARNING: Memory ${heapUsedMB}MB, CPU ${cpuPercent}%`, 'WARNING');
  }
  
  // üñ•Ô∏è ‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏•
  console.clear();
  console.log(`${colors.cyan}${colors.bright}`);
  console.log('‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà');
  console.log('‚ñà                                                      ‚ñà');
  console.log('‚ñà  üìä MCP Performance Monitor - Lightweight Mode      ‚ñà');
  console.log('‚ñà                                                      ‚ñà');
  console.log('‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà');
  console.log(`${colors.reset}\n`);
  
  // üö® ‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏Å‡∏≤‡∏£‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô
  console.log(`${alertColor}üö® Status: ${alertLevel}${colors.reset}`);
  console.log(`‚è∞ Uptime: ${Math.round((Date.now() - stats.startTime) / 1000)}s`);
  console.log(`üìÖ Time: ${new Date().toLocaleString('th-TH')}\n`);
  
  // üíæ ‡∏´‡∏ô‡πà‡∏ß‡∏¢‡∏Ñ‡∏ß‡∏≤‡∏°‡∏à‡∏≥ Process
  console.log(`${colors.bright}üíæ Process Memory:${colors.reset}`);
  console.log(`   Heap Used:  ${createProgressBar(heapUsedMB, 2048)} (${heapUsedMB}MB)`);
  console.log(`   Heap Total: ${heapTotalMB}MB`);
  console.log(`   RSS:        ${rssMB}MB`);
  console.log(`   External:   ${externalMB}MB\n`);
  
  // üñ•Ô∏è ‡∏´‡∏ô‡πà‡∏ß‡∏¢‡∏Ñ‡∏ß‡∏≤‡∏°‡∏à‡∏≥‡∏£‡∏∞‡∏ö‡∏ö
  console.log(`${colors.bright}üñ•Ô∏è  System Memory:${colors.reset}`);
  console.log(`   Total:      ${systemMemMB}MB`);
  console.log(`   Used:       ${createProgressBar(usedSystemMemMB, systemMemMB)} (${usedSystemMemMB}MB)`);
  console.log(`   Free:       ${freeMemMB}MB\n`);
  
  // ‚ö° CPU
  console.log(`${colors.bright}‚ö° CPU Usage:${colors.reset}`);
  console.log(`   Current:    ${createProgressBar(cpuPercent, 100)} (${cpuPercent}%)`);
  console.log(`   Cores:      ${cpuCount}`);
  console.log(`   Load Avg:   ${loadAvg.map(l => l.toFixed(2)).join(', ')}\n`);
  
  // üìà ‡∏™‡∏ñ‡∏¥‡∏ï‡∏¥
  console.log(`${colors.bright}üìà Statistics:${colors.reset}`);
  console.log(`   Max Memory: ${stats.maxMemory}MB`);
  console.log(`   Avg Memory: ${stats.avgMemory.toFixed(1)}MB`);
  console.log(`   Max CPU:    ${stats.maxCpu}%`);
  console.log(`   Avg CPU:    ${stats.avgCpu.toFixed(1)}%`);
  console.log(`   Warnings:   ${stats.warnings}`);
  console.log(`   Alerts:     ${stats.alerts}\n`);
  
  // üí° ‡∏Ñ‡∏≥‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥
  console.log(`${colors.bright}üí° Recommendations:${colors.reset}`);
  if (heapUsedMB > thresholds.memory.critical) {
    console.log(`   ${colors.red}üö® CRITICAL: Restart server immediately!${colors.reset}`);
  } else if (heapUsedMB > thresholds.memory.warning) {
    console.log(`   ${colors.yellow}‚ö†Ô∏è  WARNING: Consider restarting server${colors.reset}`);
  } else if (heapUsedMB < 512) {
    console.log(`   ${colors.green}‚úÖ EXCELLENT: Memory usage is optimal${colors.reset}`);
  } else {
    console.log(`   ${colors.green}‚úÖ GOOD: Memory usage is acceptable${colors.reset}`);
  }
  
  if (cpuPercent > thresholds.cpu.critical) {
    console.log(`   ${colors.red}üö® CRITICAL: CPU usage too high!${colors.reset}`);
  } else if (cpuPercent > thresholds.cpu.warning) {
    console.log(`   ${colors.yellow}‚ö†Ô∏è  WARNING: High CPU usage detected${colors.reset}`);
  } else {
    console.log(`   ${colors.green}‚úÖ CPU usage is normal${colors.reset}`);
  }
  
  console.log(`\n${colors.bright}üîß Controls:${colors.reset}`);
  console.log(`   Ctrl+C: Exit monitor`);
  console.log(`   Log file: performance.log`);
  console.log(`   Update: Every 5 seconds\n`);
  
  console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
  
  // üìù ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å log
  writeLog(`Memory: ${heapUsedMB}MB, CPU: ${cpuPercent}%, Status: ${alertLevel}`);
}

// üéØ ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ó‡∏î‡∏™‡∏≠‡∏ö MCP Server
async function testMcpServer() {
  try {
    const response = await fetch('http://localhost:9090/health');
    if (response.ok) {
      const data = await response.json();
      console.log(`${colors.green}‚úÖ MCP Server: Online${colors.reset}`);
      console.log(`   Mode: ${data.mode}`);
      console.log(`   Servers: ${data.serverCount}`);
      return true;
    }
  } catch (error) {
    console.log(`${colors.red}‚ùå MCP Server: Offline${colors.reset}`);
    console.log(`   Error: ${error.message}`);
    return false;
  }
}

// üöÄ ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö
console.log(`${colors.cyan}üöÄ Starting MCP Performance Monitor...${colors.reset}`);
console.log(`üìä Monitoring interval: 5 seconds`);
console.log(`üìù Log file: performance.log`);
console.log(`‚ö†Ô∏è  Memory warning: ${thresholds.memory.warning}MB`);
console.log(`üö® Memory critical: ${thresholds.memory.critical}MB`);
console.log(`‚ö†Ô∏è  CPU warning: ${thresholds.cpu.warning}%`);
console.log(`üö® CPU critical: ${thresholds.cpu.critical}%\n`);

// ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ó‡∏±‡∏ô‡∏ó‡∏µ
monitorPerformance();

// ‡∏ï‡∏±‡πâ‡∏á‡πÄ‡∏ß‡∏•‡∏≤‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö
const monitorInterval = setInterval(monitorPerformance, 5000);

// üõë ‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏Å‡∏≤‡∏£‡∏õ‡∏¥‡∏î‡πÇ‡∏õ‡∏£‡πÅ‡∏Å‡∏£‡∏°
process.on('SIGINT', () => {
  console.log(`\n\n${colors.yellow}üõë Stopping performance monitor...${colors.reset}`);
  clearInterval(monitorInterval);
  
  // ‡∏™‡∏£‡∏∏‡∏õ‡∏™‡∏ñ‡∏¥‡∏ï‡∏¥
  const runtime = Math.round((Date.now() - stats.startTime) / 1000);
  console.log(`\n${colors.bright}üìä Final Statistics:${colors.reset}`);
  console.log(`   Runtime: ${runtime}s`);
  console.log(`   Max Memory: ${stats.maxMemory}MB`);
  console.log(`   Avg Memory: ${stats.avgMemory.toFixed(1)}MB`);
  console.log(`   Max CPU: ${stats.maxCpu}%`);
  console.log(`   Avg CPU: ${stats.avgCpu.toFixed(1)}%`);
  console.log(`   Warnings: ${stats.warnings}`);
  console.log(`   Alerts: ${stats.alerts}`);
  
  writeLog(`Monitor stopped. Runtime: ${runtime}s, Max Memory: ${stats.maxMemory}MB, Warnings: ${stats.warnings}, Alerts: ${stats.alerts}`, 'INFO');
  
  console.log(`\n${colors.green}‚úÖ Performance monitor stopped successfully${colors.reset}`);
  process.exit(0);
});

// ‚ùå ‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ error
process.on('uncaughtException', (error) => {
  console.error(`${colors.red}‚ùå Uncaught Exception:${colors.reset}`, error);
  writeLog(`Uncaught Exception: ${error.message}`, 'ERROR');
});

process.on('unhandledRejection', (reason, promise) => {
  console.error(`${colors.red}‚ùå Unhandled Rejection:${colors.reset}`, reason);
  writeLog(`Unhandled Rejection: ${reason}`, 'ERROR');
});

// üì§ Export ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÉ‡∏ä‡πâ‡πÄ‡∏õ‡πá‡∏ô module
module.exports = {
  monitorPerformance,
  stats,
  thresholds
};